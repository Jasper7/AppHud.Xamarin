#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
#ifndef APPHUDSDK_SWIFT_H
#define APPHUDSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wduplicate-method-match"
#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if defined(__cplusplus)
#if !defined(SWIFT_NOEXCEPT)
# define SWIFT_NOEXCEPT noexcept
#endif
#else
#if !defined(SWIFT_NOEXCEPT)
# define SWIFT_NOEXCEPT 
#endif
#endif
#if defined(__cplusplus)
#if !defined(SWIFT_CXX_INT_DEFINED)
#define SWIFT_CXX_INT_DEFINED
namespace swift {
using Int = ptrdiff_t;
using UInt = size_t;
}
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
@import StoreKit;
@import UIKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="ApphudSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
@class NSString;
@protocol ApphudDelegate;
@protocol ApphudUIDelegate;
@class ApphudPaywall;
@class SKProduct;
@class ApphudProduct;
@class ApphudPurchaseResult;
@class ApphudGroup;
@class ApphudSubscription;
@class ApphudNonRenewingPurchase;
@class ApphudReceipt;
@class ApphudUserPropertyKey;
@class UIViewController;
@class ApphudRule;
@class NSData;
enum ApphudAttributionProvider : NSInteger;

/// Entry point of the Apphud SDK. It provides access to all its features.
/// Main class of Apphud SDK.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.apphud.com/getting-started/sdk-integration/ios#initialise-sdk">Apphud SDK Initialization</a>
///   </li>
///   <li>
///     <a href="https://docs.apphud.com/getting-started/observer-mode">Observer Mode</a>
///   </li>
///   <li>
///     <a href="https://docs.apphud.com/getting-started/sdk-integration/ios#get-paywalls-version-2.3.0-or-above">Fetch Products</a>
///   </li>
///   <li>
///     <a href="https://docs.apphud.com/getting-started/sdk-integration/ios#check-subscription-status">Check Subscription Status</a>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC9ApphudSDK6Apphud") SWIFT_AVAILABILITY(ios,introduced=11.2) SWIFT_AVAILABILITY(macos,introduced=10.14.4)
@interface Apphud : NSObject
/// Initializes Apphud SDK. You should call it during app launch.
/// \param apiKey Required. Your api key.
///
/// \param userID Optional. You can provide your own unique user identifier. If <code>nil</code> passed then UUID will be generated instead.
///
/// \param observerMode Optional. Sets SDK to Observer (i.e. Analytics) mode. If you purchase products by your own code, then pass <code>true</code>. If you purchase products using <code>Apphud.purchase(..)</code> method, then pass <code>false</code>. Default value is <code>false</code>.
///
+ (void)startWithApiKey:(NSString * _Nonnull)apiKey userID:(NSString * _Nullable)userID observerMode:(BOOL)observerMode;
/// Initializes Apphud SDK with User ID & Device ID pair. Not recommended for use unless you know what you are doing.
/// \param apiKey Required. Your api key.
///
/// \param userID Optional. You can provide your own unique user identifier. If <code>nil</code> passed then UUID will be generated instead.
///
/// \param deviceID Optional. You can provide your own unique device identifier. If <code>nil</code> passed then UUID will be generated instead.
///
/// \param observerMode Optional. Sets SDK to Observer (Analytics) mode. If you purchase products by your own code, then pass <code>true</code>. If you purchase products using <code>Apphud.purchase(product)</code> method, then pass <code>false</code>. Default value is <code>false</code>.
///
+ (void)startManuallyWithApiKey:(NSString * _Nonnull)apiKey userID:(NSString * _Nullable)userID deviceID:(NSString * _Nullable)deviceID observerMode:(BOOL)observerMode;
/// Updates user ID value.
/// \param userID Required. New user ID value.
///
+ (void)updateUserID:(NSString * _Nonnull)userID;
/// Returns current userID that identifies user across his multiple devices.
/// This value may change in runtime, see <code>apphudDidChangeUserID(_ userID : String)</code> delegate method for details.
+ (NSString * _Nonnull)userID SWIFT_WARN_UNUSED_RESULT;
/// Returns current device ID. You should use it only if you want to implement custom logout/login flow by saving User ID & Device ID pair for each app user.
+ (NSString * _Nonnull)deviceID SWIFT_WARN_UNUSED_RESULT;
/// Logs out current user, clears all saved data and resets SDK to uninitialized state. You will need to call <code>Apphud.start()</code> or <code>Apphud.startManually()</code> again to initilize SDK with a new user.
/// This might be useful if you have your custom logout/login flow and you want to take control of each logged-in user’s subscription status.
/// <em>Note</em>: If previous user had active subscription, the new logged-in user can still restore purchases on this device and both users will be merged under the previous paid one, because Apple ID is tied to a device.
+ (void)logout;
/// Set a delegate.
/// \param delegate Required. Any ApphudDelegate conformable object.
///
+ (void)setDelegate:(id <ApphudDelegate> _Nonnull)delegate;
/// Set a UI delegate.
/// \param delegate Required. Any ApphudUIDelegate conformable object.
///
+ (void)setUIDelegate:(id <ApphudUIDelegate> _Nonnull)delegate;
/// Returns paywalls configured in Apphud Dashboard > Product Hub > Paywalls. Each paywall contains an array of <code>ApphudProduct</code> objects that you use for purchase.
/// <code>ApphudProduct</code> is Apphud’s wrapper around StoreKit’s <code>SKProduct</code>.
/// Returns <code>nil</code> if paywalls are not yet populated with SKProducts from the App Store. To get notified when paywalls are ready to use, use <code>paywallsDidLoadCallback</code> – when it’s called, paywalls are populated with their <code>SKProducts</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ApphudPaywall *> * _Nullable paywalls;)
+ (NSArray<ApphudPaywall *> * _Nullable)paywalls SWIFT_WARN_UNUSED_RESULT;
/// Returns paywalls configured in Apphud Dashboard > Product Hub > Paywalls. Each paywall contains an array of <code>ApphudProduct</code> objects that you use for purchase.
/// <code>ApphudProduct</code> is Apphud’s wrapper around StoreKit’s <code>SKProduct</code>. This is a duplicate for <code>paywallsDidFullyLoad</code> method of ApphudDelegate.
/// This callback is called when paywalls are populated with their StoreKit products. Callback is called immediately if paywalls are already loaded.
/// It is safe to call this method multiple times – previous callback will not be overwritten, but will be added to array and once paywalls are loaded, all callbacks will be called.
+ (void)paywallsDidLoadCallback:(void (^ _Nonnull)(NSArray<ApphudPaywall *> * _Nonnull))callback;
/// <em>Deprecated</em>. Fetches paywalls configured in Apphud dashboard. This makes an API request to Apphud. Always check if there are cached paywalls on device by using paywalls method.
+ (void)getPaywallsWithCallback:(void (^ _Nonnull)(NSArray<ApphudPaywall *> * _Nullable, NSError * _Nullable))callback SWIFT_DEPRECATED_MSG("Use `func paywallsDidLoadCallback` method instead.");
/// If you want to use A/B experiments while running SDK in <code>Observer Mode</code> you should manually send paywall identifier to Apphud using this method.
/// Example:
/// \code
/// Apphud.willPurchaseProductFromPaywall("main_paywall")
/// YourClass.purchase(someProduct)
///
/// \endcodenote:
/// You have to add paywalls in Apphud Dashboard > Product Hub > Paywalls.
/// important:
/// You must call this method right before your own purchase method.
+ (void)willPurchaseProductFromPaywall:(NSString * _Nonnull)identifier;
/// This notification is sent when <code>SKProduct</code>s are fetched from the App Store. Note that you have to add all product identifiers in Apphud Dashboard > Product Hub > Products.
/// You can use <code>productsDidFetchCallback</code> callback or observe for <code>didFetchProductsNotification()</code> or implement <code>apphudDidFetchStoreKitProducts</code> delegate method. Use whatever you like most.
/// Best practise is not to use this method, but implement paywalls logic by adding your paywall configuration in Apphud Dashboard > Product Hub > Paywalls.
+ (NSNotificationName _Nonnull)didFetchProductsNotification SWIFT_WARN_UNUSED_RESULT;
/// This callback is called when <code>SKProduct</code>s are fetched from the App Store. Note that you have to add all product identifiers in Apphud Dashboard > Product Hub > Products.
/// You can use <code>productsDidFetchCallback</code> callback or observe for <code>didFetchProductsNotification()</code> or implement <code>apphudDidFetchStoreKitProducts</code> delegate method. Use whatever you like most.
/// Best practise is not to use this method, but implement paywalls logic by adding your paywall configuration in Apphud Dashboard > Product Hub > Paywalls.
+ (void)productsDidFetchCallback:(void (^ _Nonnull)(NSArray<SKProduct *> * _Nonnull, NSError * _Nullable))callback;
/// Refreshes <code>SKProduct</code>s from the App Store. You have to add all product identifiers in Apphud Dashboard > Product Hub > Products.
/// Best practise is not to use this method, but implement paywalls logic by adding your paywall configuration in Apphud Dashboard > Product Hub > Paywalls.
/// note:
/// You shouldn’t call this method at app launch, because Apphud SDK automatically fetches products during initialization. Only use this method as a fallback.
+ (void)refreshStoreKitProducts:(void (^ _Nullable)(NSArray<SKProduct *> * _Nonnull, NSError * _Nullable))callback;
/// Returns array of <code>SKProduct</code> objects that you added in Apphud > Product Hub > Products.
/// Note that this method will return <code>nil</code> if products are not yet fetched from the App Store. You should observe for <code>Apphud.didFetchProductsNotification()</code> notification or implement  <code>apphudDidFetchStoreKitProducts</code> delegate method or set <code>productsDidFetchCallback</code> block.
/// important:
/// Best practise is not to use this method, but implement paywalls logic by adding your paywall configuration in Apphud Dashboard > Product Hub > Paywalls.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<SKProduct *> * _Nullable storeKitProducts;)
+ (NSArray<SKProduct *> * _Nullable)storeKitProducts SWIFT_WARN_UNUSED_RESULT;
/// Returns <code>SKProduct</code> object by product identifier. Note that you have to add this product identifier in Apphud Dashboard > Product Hub > Products.
/// note:
/// Will return <code>nil</code> if product is not yet fetched from the App Store.
/// important:
/// Best practise is not to use this method, but implement paywalls logic by adding your paywall configuration in Apphud Dashboard > Product Hub > Paywalls.
+ (SKProduct * _Nullable)productWithProductIdentifier:(NSString * _Nonnull)productIdentifier SWIFT_WARN_UNUSED_RESULT;
/// Initiates purchase of <code>ApphudProduct</code> object from your <code>ApphudPaywall</code> and automatically submits App Store Receipt to Apphud.
/// note:
/// You are not required to purchase product using Apphud SDK methods. You can purchase subscription or any in-app purchase using your own code. App Store receipt will be sent to Apphud anyway.
/// \param product Required. <code>ApphudProduct</code> object from your <code>ApphudPaywall</code>. You must first configure paywalls in Apphud Dashboard > Product Hub > Paywalls.
///
/// \param callback Optional. Returns <code>ApphudPurchaseResult</code> object.
///
+ (void)purchaseApphudProduct:(ApphudProduct * _Nonnull)product callback:(void (^ _Nullable)(ApphudPurchaseResult * _Nonnull))callback;
/// Deprecated. Purchase product by product identifier. Use this method if you don’t use Apphud Paywalls logic.
/// note:
/// A/B Experiments feature will not work if you purchase products by your own code or by using this method. If you want to use A/B experiments, you must use Apphud Paywalls and initiate purchase of  <code>ApphudProduct</code> object instead.
/// important:
/// Best practise is not to use this method, but implement paywalls logic by adding your paywall configuration in Apphud Dashboard > Product Hub > Paywalls.
/// \param product Required. Identifier of the product that user wants to purchase. If you don’t use Apphud paywalls, you can use this purchase method.
///
/// \param callback Optional. Returns <code>ApphudPurchaseResult</code> object.
///
+ (void)purchaseById:(NSString * _Nonnull)productId callback:(void (^ _Nullable)(ApphudPurchaseResult * _Nonnull))callback;
/// Purchases product and automatically submits App Store Receipt to Apphud. This method doesn’t wait until Apphud validates receipt from Apple and immediately returns transaction object. This method may be useful if you don’t care about receipt validation in callback.
/// note:
/// When using this method properties <code>subscription</code> and <code>nonRenewingPurchase</code> in <code>ApphudPurchaseResult</code> will always be <code>nil</code> !
/// \param productId Required. Identifier of the product that user wants to purchase.
///
/// \param callback Optional. Returns <code>ApphudPurchaseResult</code> object.
///
+ (void)purchaseWithoutValidationById:(NSString * _Nonnull)productId callback:(void (^ _Nullable)(ApphudPurchaseResult * _Nonnull))callback;
/// Purchases subscription (promotional) offer and automatically submits App Store Receipt to Apphud.
/// note:
/// This method automatically sends in-app purchase receipt to Apphud, so you don’t need to call <code>submitReceipt</code> method.
/// \param product Required. This is an <code>SKProduct</code> object that user wants to purchase.
///
/// \param discountID Required. This is a <code>SKProductDiscount</code> Identifier String object that you would like to apply.
///
/// \param callback Optional. Returns <code>ApphudPurchaseResult</code> object.
///
+ (void)purchasePromo:(SKProduct * _Nonnull)product discountID:(NSString * _Nonnull)discountID :(void (^ _Nullable)(ApphudPurchaseResult * _Nonnull))callback SWIFT_AVAILABILITY(ios,introduced=12.2);
/// Displays an offer code redemption sheet.
+ (void)presentOfferCodeRedemptionSheet SWIFT_AVAILABILITY(ios,introduced=14.0);
/// You can grant free promotional subscription to user. Returns <code>true</code> in a callback if promotional was granted. After this <code>hasActiveSubscription()</code> method will return <code>true</code>.
/// note:
/// You should pass either <code>productId</code> (recommended) or <code>permissionGroup</code> OR both parameters <code>nil</code>. Sending both <code>productId</code> and <code>permissionGroup</code> parameters will result in <code>productId</code> being used. Docs](https://docs.apphud.com/getting-started/product-hub/products)
/// \param daysCount Required. Number of days of free premium usage. For lifetime promotionals just pass extremely high value, like 10000.
///
/// \param productId Optional*. Recommended. Product Id of promotional subscription. See <em>Note</em> message above for details.
///
/// \param permissionGroup Optional*. Permission Group of promotional subscription. Use this parameter in case you have multiple permission groups. See <em>Note</em> message above for details.
///
/// \param callback Optional. Returns <code>true</code> if promotional subscription was granted.
///
+ (void)grantPromotionalWithDaysCount:(NSInteger)daysCount productId:(NSString * _Nullable)productId permissionGroup:(ApphudGroup * _Nullable)permissionGroup callback:(void (^ _Nullable)(BOOL))callback;
/// Logs “Paywall Shown” event that will be used in Apphud Dashboard.
/// note:
/// For more information  - <a href="https://docs.apphud.com/events/events#paywall-shown">Paywall Shown Event Documentation</a>
+ (void)paywallShown:(ApphudPaywall * _Nonnull)paywall;
/// Logs “Paywall Closed” event that will be used in Apphud Dashboard.
/// note:
/// For more information  - <a href="https://docs.apphud.com/events/events#paywall-closed">Paywall Closed Event Documentation</a>
+ (void)paywallClosed:(ApphudPaywall * _Nonnull)paywall;
/// Returns <code>true</code> if user has active subscription or non renewing purchase (lifetime).
/// Use this method to determine whether or not user has active premium access. If you have consumable purchases, this method won’t operate correctly, because Apphud SDK doesn’t differ consumables from non-consumables.
/// important:
/// You should not use this method if you have consumable in-app purchases, like coin packs.
+ (BOOL)hasPremiumAccess SWIFT_WARN_UNUSED_RESULT;
/// Returns <code>true</code> if user has active subscription.
/// Use this method to determine whether or not user has active premium subscription.
/// important:
/// Note that if you have lifetime (nonconsumable) or consumable purchases, you must use another <code>Apphud/isNonRenewingPurchaseActive(productIdentifier:)</code> method.
+ (BOOL)hasActiveSubscription SWIFT_WARN_UNUSED_RESULT;
/// Permission groups configured in Apphud dashboard > Product Hub > Products. Groups are cached on device.
/// important:
/// Note that this method may be <code>nil</code> at first launch of the app.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ApphudGroup *> * _Nonnull permissionGroups;)
+ (NSArray<ApphudGroup *> * _Nonnull)permissionGroups SWIFT_WARN_UNUSED_RESULT;
/// Returns subscription object that current user has ever purchased. Subscriptions are cached on device.
/// You should check <code>Apphud.hasActiveSubscription()</code> method or <code>subscription.isActive()</code> value to determine whether or not to unlock premium functionality to the user.
/// If you have more than one subscription group in your app, use <code>subscriptions()</code> method and get <code>isActive</code> value for your desired subscription.
/// note:
/// If returned object is not <code>nil</code>, it doesn’t mean that subsription is active.
+ (ApphudSubscription * _Nullable)subscription SWIFT_WARN_UNUSED_RESULT;
/// Returns an array of all subscriptions that this user has ever purchased. Subscriptions are cached on device.
/// Use this method if you have more than one subsription group in your app.
+ (NSArray<ApphudSubscription *> * _Nullable)subscriptions SWIFT_WARN_UNUSED_RESULT;
/// Returns an array of all standard in-app purchases (consumables, nonconsumables or nonrenewing subscriptions) that this user has ever purchased. Purchases are cached on device. This array is sorted by purchase date. Apphud only tracks consumables if they were purchased after integrating Apphud SDK.
+ (NSArray<ApphudNonRenewingPurchase *> * _Nullable)nonRenewingPurchases SWIFT_WARN_UNUSED_RESULT;
/// Returns <code>true</code> if current user has purchased standard in-app purchase with given product identifier. Returns <code>false</code> if this product is refunded or never purchased. Includes consumables, nonconsumables or non-renewing subscriptions. Apphud only tracks consumables if they were purchased after integrating Apphud SDK.
/// note:
/// Purchases are sorted by purchase date, so it returns Bool value for the most recent purchase by given product identifier.
+ (BOOL)isNonRenewingPurchaseActiveWithProductIdentifier:(NSString * _Nonnull)productIdentifier SWIFT_WARN_UNUSED_RESULT;
/// Basically the same as restoring purchases.
+ (void)validateReceiptWithCallback:(void (^ _Nonnull)(NSArray<ApphudSubscription *> * _Nullable, NSArray<ApphudNonRenewingPurchase *> * _Nullable, NSError * _Nullable))callback;
/// Implements <code>Restore Purchases</code> mechanism. Basically it just sends current App Store Receipt to Apphud and returns subscriptions info.
/// note:
/// Even if callback returns some subscription, it doesn’t mean that subscription is active. You should check <code>subscription.isActive()</code> value.
/// \param callback Required. Returns array of subscription (or subscriptions in case you have more than one subscription group), array of standard in-app purchases and an error. All of three parameters are optional.
///
+ (void)restorePurchasesWithCallback:(void (^ _Nonnull)(NSArray<ApphudSubscription *> * _Nullable, NSArray<ApphudNonRenewingPurchase *> * _Nullable, NSError * _Nullable))callback;
/// If you already have a live app with paying users and you want Apphud to track their purchases, you should import their App Store receipts into Apphud. Call this method at launch of your app for your paying users. This method should be used only to migrate existing paying users that are not yet tracked by Apphud.
/// Example:
/// \code
///    // hasPurchases - is your own boolean value indicating that current user is paying user.
///    if hasPurchases {
///        Apphud.migratePurchasesIfNeeded { _, _, _ in}
///    }
///
/// \endcodenote:
/// You can remove this method after a some period of time, i.e. when you are sure that all paying users are already synced with Apphud.
+ (void)migratePurchasesIfNeededWithCallback:(void (^ _Nonnull)(NSArray<ApphudSubscription *> * _Nullable, NSArray<ApphudNonRenewingPurchase *> * _Nullable, NSError * _Nullable))callback;
/// Returns base64 encoded App Store receipt string, if available.
+ (NSString * _Nullable)appStoreReceipt SWIFT_WARN_UNUSED_RESULT;
/// Fetches raw receipt info in a wrapped <code>ApphudReceipt</code> model class. This might be useful to get <code>original_application_version</code> value.
+ (void)fetchRawReceiptInfo:(void (^ _Nonnull)(ApphudReceipt * _Nullable))completion;
/// Set custom user property. Value must be one of: <code>Int</code>, <code>Float</code>, <code>Double</code>, <code>Bool</code>, <code>String</code>, <code>NSNumber</code>, <code>NSString</code>, <code>NSNull</code>, <code>nil</code>.
/// Example:
/// \code
/// // use built-in property key
/// Apphud.setUserProperty(key: .email, value: "user4@example.com", setOnce: true)
/// // use custom property key
/// Apphud.setUserProperty(key: .init("custom_test_property_1"), value: 0.5)
///
/// \endcode<h4>You can use several built-in keys with their value types:</h4>
/// <code>.email</code>: User email. Value must be String.
/// <code>.name</code>: User name. Value must be String.
/// <code>.phone</code>: User phone number. Value must be String.
/// <code>.age</code>: User age. Value must be Int.
/// <code>.gender</code>: User gender. Value must be one of: “male”, “female”, “other”.
/// <code>.cohort</code>: User install cohort. Value must be String.
/// \param key Required. Initialize class with custom string or using built-in keys. See example above.
///
/// \param value Required/Optional. Pass <code>nil</code> or <code>NSNull</code> to remove given property from Apphud.
///
/// \param setOnce Optional. Pass <code>true</code> to make this property non-updatable.
///
+ (void)setUserPropertyWithKey:(ApphudUserPropertyKey * _Nonnull)key value:(id _Nullable)value setOnce:(BOOL)setOnce;
/// Increment custom user property. Value must be one of: <code>Int</code>, <code>Float</code>, <code>Double</code> or <code>NSNumber</code>.
/// Example:
/// \code
/// Apphud.incrementUserProperty(key: .init("progress"), by: 0.5)
///
/// \endcode\param key Required. Use your custom string key or some of built-in keys.
///
/// \param by Required/Optional. You can pass negative value to decrement.
///
+ (void)incrementUserPropertyWithKey:(ApphudUserPropertyKey * _Nonnull)key by:(id _Nonnull)by;
/// Presents Apphud screen that was delayed for presentation, i.e. <code>false</code> was returned in <code>apphudShouldShowScreen</code> delegate method.
+ (void)showPendingScreen;
/// Screen view controller that is pending for presentation. This is the screen that is triggered by your pending Rule. You can use <code>showPendingScreen</code> method or present this controller manually.
+ (UIViewController * _Nullable)pendingScreenController SWIFT_WARN_UNUSED_RESULT;
/// Rule with a screen that was delayed for presentation.
+ (ApphudRule * _Nullable)pendingRule SWIFT_WARN_UNUSED_RESULT;
/// Submit device push token to Apphud.
/// \param token Push token in Data class.
///
/// \param callback Returns true if successfully sent.
///
+ (void)submitPushNotificationsTokenWithToken:(NSData * _Nonnull)token callback:(void (^ _Nullable)(BOOL))callback;
+ (BOOL)handlePushNotificationWithApsInfo:(NSDictionary * _Nonnull)apsInfo;
/// Submit Advertising Identifier (IDFA) to Apphud. This is used to properly match user with attribution platforms (AppsFlyer, Facebook, etc.)
+ (void)setAdvertisingIdentifier:(NSString * _Nonnull)idfa;
/// Submit attribution data to Apphud from your attribution network provider.
/// \param data Required. Attribution dictionary.
///
/// \param provider Required. Attribution provider name. Available values: .appsFlyer. Will be added more soon.
///
/// \param identifier Optional. Identifier that matches Apphud and Attrubution provider. Required for AppsFlyer.
///
/// \param callback Optional. Returns true if successfully sent.
///
+ (void)addAttributionWithData:(NSDictionary * _Nullable)data from:(enum ApphudAttributionProvider)provider identifer:(NSString * _Nullable)identifer callback:(void (^ _Nullable)(BOOL))callback;
/// Checks whether the given product is eligible for purchasing introductory offer (<code>free trial</code>, <code>pay as you go</code> or <code>pay up front</code> modes).
/// New and returning customers are eligible for introductory offers including free trials as follows:
/// <ul>
///   <li>
///     New subscribers are always eligible.
///   </li>
///   <li>
///     Lapsed subscribers who renew are eligible if they haven’t previously used an introductory offer for the given product (or any product within the same subscription group).
///   </li>
/// </ul>
/// \param product Required. This is an <code>SKProduct</code> object for which you want to check intro offers eligibility.
///
/// \param callback Returns true if product is eligible for purchasing introductory offer.
///
+ (void)checkEligibilityForIntroductoryOfferWithProduct:(SKProduct * _Nonnull)product callback:(void (^ _Nonnull)(BOOL))callback;
/// Checks whether the given product is eligible for purchasing any of it’s promotional offers.
/// Only customers who already purchased subscription are eligible for promotional offer for the given product (or any product within the same subscription group).
/// \param product Required. This is an <code>SKProduct</code> object for which you want to check promo offers eligibility.
///
/// \param callback Returns true if product is eligible for purchasing promotional any of it’s promotional offers.
///
+ (void)checkEligibilityForPromotionalOfferWithProduct:(SKProduct * _Nonnull)product callback:(void (^ _Nonnull)(BOOL))callback SWIFT_AVAILABILITY(ios,introduced=12.2);
/// Checks promotional offers eligibility for multiple products at once.
/// \param products Required. This is an array of <code>SKProduct</code> objects for which you want to check promo offers eligibilities.
///
/// \param callback Returns dictionary with product identifiers and boolean values.
///
+ (void)checkEligibilitiesForPromotionalOffersWithProducts:(NSArray<SKProduct *> * _Nonnull)products callback:(void (^ _Nonnull)(NSDictionary<NSString *, NSNumber *> * _Nonnull))callback SWIFT_AVAILABILITY(ios,introduced=12.2);
/// Checks introductory offers eligibility for multiple products at once.
/// \param products Required. This is an array of <code>SKProduct</code> objects for which you want to check introductory offers eligibilities.
///
/// \param callback Returns dictionary with product identifiers and boolean values.
///
+ (void)checkEligibilitiesForIntroductoryOffersWithProducts:(NSArray<SKProduct *> * _Nonnull)products callback:(void (^ _Nonnull)(NSDictionary<NSString *, NSNumber *> * _Nonnull))callback;
/// Enables debug logs. You should call this method before SDK initialization.
+ (void)enableDebugLogs;
/// Returns <code>true</code> if current build is running on sumulator or Debug/TestFlight modes. Returns <code>false</code> if current build is App Store build.
+ (BOOL)isSandbox SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// List of available attribution providers
/// has to make Int in order to support Objective-C
typedef SWIFT_ENUM(NSInteger, ApphudAttributionProvider, closed) {
  ApphudAttributionProviderAppsFlyer = 0,
  ApphudAttributionProviderAdjust = 1,
  ApphudAttributionProviderAppleSearchAds = 2,
  ApphudAttributionProviderAppleAdsAttribution = 3,
  ApphudAttributionProviderFirebase = 4,
  ApphudAttributionProviderFacebook = 5,
};

@class SKPaymentTransaction;

/// A public protocol that provides access to Apphud’s main public methods, describing the behavior of the user and the state of his subscriptions.
SWIFT_PROTOCOL("_TtP9ApphudSDK14ApphudDelegate_") SWIFT_AVAILABILITY(macos,introduced=10.14.4)
@protocol ApphudDelegate
@optional
/// Returns array of subscriptions that user ever purchased. Empty array means user never purchased a subscription. If you have just one subscription group in your app, you will always receive just one subscription in an array.
/// This method is called when subscription is purchased or updated (for example, status changed from <code>trial</code> to <code>expired</code> or <code>isAutorenewEnabled</code> changed to <code>false</code>). SDK also checks for subscription updates when app becomes active.
- (void)apphudSubscriptionsUpdated:(NSArray<ApphudSubscription *> * _Nonnull)subscriptions;
/// Called when any of non renewing purchases changes. Called when purchase is made or has been refunded.
- (void)apphudNonRenewingPurchasesUpdated:(NSArray<ApphudNonRenewingPurchase *> * _Nonnull)purchases;
/// Called when user ID has been changed. Use this if you implement integrations with Analytics services.
/// Please read following if you implement integrations: <code>https://docs.apphud.com/docs/en/sdk-integration#user-identifier-and-integrations</code>
/// This delegate method is called in 2 cases:
/// <ul>
///   <li>
///     When Apphud has merged two users into a single user (for example, after user has restored purchases from his another device).
///     Merging users is done in the following way: after App Store receipt has been sent to Apphud, server tries to find the same receipt in the database.
///     If the same App Store receipt has been found, Apphud merges two users into a single user with two devices and then returns an original userID.
///   </li>
/// </ul>
/// <em>Note</em>: Only subscriber devices are mergable. If non-premium user uses the app from two different devices, Apphud won’t be able to know that these devices belong to the same user.
/// <ul>
///   <li>
///     After manual call of <code>updateUserID(userID : String)</code> method.
///   </li>
/// </ul>
- (void)apphudDidChangeUserID:(NSString * _Nonnull)userID;
/// Deprecated. Use <code>func getPaywalls</code> method instead.
/// This method gets called when products are fetched from App Store. Returns optional Error from StoreKit, if exists.
- (void)apphudDidFetchStoreKitProducts:(NSArray<SKProduct *> * _Nonnull)products :(NSError * _Nullable)error;
- (void)apphudDidFetchStoreKitProducts:(NSArray<SKProduct *> * _Nonnull)products;
/// Implements mechanism of purchasing In-App Purchase initiated directly from the App Store page.
/// You must return a callback block which will be called when a payment is finished. If you don’t implement this method or return <code>nil</code> then a payment will not start; you can also save the product and return <code>nil</code> to initiate a payment later by yourself. Read Apple documentation for details: https://developer.apple.com/documentation/storekit/in-app_purchase/promoting_in-app_purchases
- (void (^ _Nullable)(ApphudPurchaseResult * _Nonnull))apphudShouldStartAppStoreDirectPurchase:(SKProduct * _Nonnull)product SWIFT_WARN_UNUSED_RESULT;
/// Optional. Specify a list of product identifiers to fetch from the App Store.
/// If you don’t implement this method, then product identifiers will be fetched from Apphud servers.
/// Implementing this delegate method gives you more reliabality on fetching products and a little more speed on loading due to skipping Apphud request, but also gives less flexibility because you have to hardcode product identifiers this way.
- (NSArray<NSString *> * _Nonnull)apphudProductIdentifiers SWIFT_WARN_UNUSED_RESULT;
/// Called when Apphud SDK detects a purchase that was made outside of Apphud SDK purchase methods. It is also useful to intercept purchases made using Promo Codes for in-app purchases. If user redeems promo code for in-app purchase in the App Store, then opens the app, this delegate method will be called, so you will be able to handle successful payment on your side.
/// Return <code>true</code> if you would like Apphud SDK to finish this transaction. If you return <code>false</code>, then you must call <code>SKPaymentQueue.default().finishTransaction(transaction)</code>.
/// See optional <code>transaction</code> property of <code>result</code> object.
- (BOOL)apphudDidObservePurchaseWithResult:(ApphudPurchaseResult * _Nonnull)result SWIFT_WARN_UNUSED_RESULT;
/// Called when Apphud SDK detects a deferred or interrupted purchase, this may happen when SCA confirmation is needed, in the case of parental control and some other cases
- (void)handleDeferredTransactionWithTransaction:(SKPaymentTransaction * _Nonnull)transaction;
/// Called when user is registered in Apphud [or used from cache]. This method is called once per app lifecycle.
/// The <code>rawPaywalls</code> array may not yet have SKProducts, so this method should not be used for paywalls management.
/// However, if using A/B Testing, <code>rawPaywalls</code> can be used to fetch <code>experimentName</code>, <code>variationName</code> or other parameters like <code>json</code> from your experimental paywall.
- (void)userDidLoadWithRawPaywalls:(NSArray<ApphudPaywall *> * _Nonnull)rawPaywalls;
/// Called when paywalls are fully loaded with their SKProducts. This is a duplicate for <code>Apphud.paywallsDidLoadCallback {}</code> method.
- (void)paywallsDidFullyLoadWithPaywalls:(NSArray<ApphudPaywall *> * _Nonnull)paywalls;
@end

@class NSCoder;

/// Custom Apphud wrapper around NSError.
SWIFT_CLASS("_TtC9ApphudSDK11ApphudError")
@interface ApphudError : NSError
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder SWIFT_UNAVAILABLE;
- (nonnull instancetype)initWithDomain:(NSString * _Nonnull)domain code:(NSInteger)code userInfo:(NSDictionary<NSString *, id> * _Nullable)dict SWIFT_UNAVAILABLE;
@end


/// Apphud class which describes products permission groups
SWIFT_CLASS("_TtC9ApphudSDK11ApphudGroup") SWIFT_AVAILABILITY(macos,introduced=10.14.4)
@interface ApphudGroup : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Class for storing user data
SWIFT_CLASS("_TtC9ApphudSDK14ApphudKeychain")
@interface ApphudKeychain : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSDate;

/// Custom Apphud class containing all information about customer non-renewing purchase
SWIFT_CLASS("_TtC9ApphudSDK25ApphudNonRenewingPurchase")
@interface ApphudNonRenewingPurchase : NSObject
/// Product identifier of this subscription
@property (nonatomic, readonly, copy) NSString * _Nonnull productId;
/// Date when user bought regular in-app purchase.
@property (nonatomic, readonly, copy) NSDate * _Nonnull purchasedAt;
/// Canceled date of in-app purchase, i.e. refund date. Nil if in-app purchase is not refunded.
@property (nonatomic, readonly, copy) NSDate * _Nullable canceledAt;
/// Returns <code>true</code> if purchase is made in test environment, i.e. sandbox or local purchase.
@property (nonatomic, readonly) BOOL isSandbox;
/// Returns <code>true</code> if purchase was made using Local StoreKit Configuration File. Read more: https://docs.apphud.com/getting-started/sandbox#testing-purchases-using-local-storekit-configuration-file
@property (nonatomic, readonly) BOOL isLocal;
/// Returns <code>true</code> if purchase is not refunded.
- (BOOL)isActive SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// An object associated with purchases container (Paywall).
/// Paywalls configured in Apphud Dashboard > Product Hub > Paywalls. Each paywall contains an array of <code>ApphudProduct</code> objects that you use for purchase. A paywall is a product array with custom JSON. The array is ordered and may be used to display products on your in-app purchase screen.
/// <h4>Related Articles:</h4>
/// To get paywall by identifier :
/// \code
/// Apphud.paywallsDidLoadCallback { paywalls in
///    let paywall = paywalls.first(where: {$0.identifier == "custom_paywall_identifier"})
/// }
///
/// \endcodenote:
/// An alternative way of getting <code>Apphud/paywalls</code>
/// important:
/// For more information  - <a href="https://docs.apphud.com/getting-started/product-hub/paywalls">Paywalls Documentation</a>
SWIFT_CLASS("_TtC9ApphudSDK13ApphudPaywall")
@interface ApphudPaywall : NSObject
/// Array of products
@property (nonatomic, readonly, copy) NSArray<ApphudProduct *> * _Nonnull products;
/// Your custom paywall identifier from Apphud Dashboard
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// It’s possible to make a paywall default – it’s a special alias name, that can be assigned to only ONE paywall at a time. There can be no default paywalls at all. It’s up to you whether you want to have them or not.
@property (nonatomic, readonly) BOOL isDefault;
/// A/B test experiment name
@property (nonatomic, copy) NSString * _Nullable experimentName;
/// A/B test variation name
@property (nonatomic, copy) NSString * _Nullable variationName;
/// A/B test paywall identifier
@property (nonatomic, copy) NSString * _Nullable fromPaywall;
/// Insert any parameters you need into custom JSON. It could be titles, descriptions, localisations, font, background and color parameters, URLs to media content, etc. Parameters count are not limited.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable json;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Apphud’s wrapper around <code>SKProduct</code>.
/// In-App Purchase must configured in App Store Connect and should be added to Apphud Dashboard > Product Hub > Products.
/// <code>ApphudProduct</code> is Apphud’s wrapper around StoreKit’s <code>SKProduct</code>.
/// note:
/// For more information  - <a href="https://docs.apphud.com/getting-started/product-hub/products">Product Hub Documentation</a>
SWIFT_CLASS("_TtC9ApphudSDK13ApphudProduct")
@interface ApphudProduct : NSObject
/// Product identifier from App Store Connect.
@property (nonatomic, readonly, copy) NSString * _Nonnull productId;
/// Product name from Apphud Dashboard
@property (nonatomic, readonly, copy) NSString * _Nullable name;
/// Always <code>app_store</code> in iOS SDK.
@property (nonatomic, readonly, copy) NSString * _Nonnull store;
/// When paywalls are successfully loaded, skProduct model will always be present if App Store returned model for this product id. getPaywalls method will return callback only when StoreKit products are fetched and mapped with Apphud products.
/// May be <code>nil</code> if product identifier is invalid, or product is not available in App Store Connect.
@property (nonatomic, readonly, strong) SKProduct * _Nullable skProduct;
/// Current product’s paywall identifier, if available.
@property (nonatomic, readonly, copy) NSString * _Nullable paywallIdentifier;
@property (nonatomic, readonly, copy) NSString * _Nullable paywallId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// General class that is returned in purchase block.
/// Using class instead of struct in order to support Objective-C
SWIFT_CLASS("_TtC9ApphudSDK20ApphudPurchaseResult") SWIFT_AVAILABILITY(macos,introduced=10.14.4)
@interface ApphudPurchaseResult : NSObject
/// Autorenewable subscription object. May be nil if error occurred or if non renewing product purchased instead. Nil if <code>purchaseWithoutValidation</code> method called.
@property (nonatomic, readonly, strong) ApphudSubscription * _Nullable subscription;
/// Standard in-app purchase (non-consumable, consumable or non-renewing subscription) object. May be nil if error occurred or if auto-renewable subscription purchased instead. Nil if <code>purchaseWithoutValidation</code> method called.
@property (nonatomic, readonly, strong) ApphudNonRenewingPurchase * _Nullable nonRenewingPurchase;
/// Transaction from StoreKit. May be nil, if no transaction made. For example, if couldn’t sign promo offer or couldn’t get App Store receipt.
@property (nonatomic, readonly, strong) SKPaymentTransaction * _Nullable transaction;
/// This error can be of three types. Check for error class.
/// <ul>
///   <li>
///     <code>SKError</code> from StoreKit with <code>SKErrorDomain</code> codes. This is a system error when purchasing transaction.
///   </li>
///   <li>
///     <code>NSError</code> from HTTP Client with <code>NSURLErrorDomain</code> codes. This is a network/server issue when uploading receipt to Apphud.
///   </li>
///   <li>
///     Custom <code>ApphudError</code> without codes. For example, if couldn’t sign promo offer or couldn’t get App Store receipt.
///   </li>
/// </ul>
@property (nonatomic, readonly) NSError * _Nullable error;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// <code>ApphudReceipt</code> is Apphud’s wrapper around StoreKit’s <code>Receipt</code>.
SWIFT_CLASS("_TtC9ApphudSDK13ApphudReceipt") SWIFT_AVAILABILITY(macos,introduced=10.14.4)
@interface ApphudReceipt : NSObject
/// The version of the app that the user originally purchased. This value does not change, and corresponds to the value of CFBundleVersion (in iOS) or CFBundleShortVersionString (in macOS) in the Info.plist file of the original purchase. In the sandbox environment, the value is always “1.0”.
/// Value is <code>nil</code> in StoreKit Testing generated receipts.
@property (nonatomic, copy) NSString * _Nullable originalApplicationVersion;
/// The time of the original app purchase. Value is <code>nil</code> in StoreKit Testing generated receipts.
@property (nonatomic, readonly, copy) NSDate * _Nullable originalPurchaseDate;
/// The time the App Store generated the receipt.
@property (nonatomic, readonly, copy) NSDate * _Nullable receiptCreationDate;
/// The app’s version number. The app’s version number corresponds to the value of CFBundleVersion (in iOS) or CFBundleShortVersionString (in macOS) in the Info.plist. In production, this value is the current version of the app on the device based on the receipt_creation_date_ms. In the sandbox, the value is always “1.0”.
@property (nonatomic, copy) NSString * _Nonnull applicationVersion;
/// The bundle identifier for the app to which the receipt belongs.
@property (nonatomic, copy) NSString * _Nonnull bundleId;
/// Raw receipt JSON
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nullable rawJSON;
@end


/// An object containing all incoming Rule information.
SWIFT_CLASS("_TtC9ApphudSDK10ApphudRule")
@interface ApphudRule : NSObject
/// Rule name that is visible in Apphud Rules Dashboard
@property (nonatomic, readonly, copy) NSString * _Nonnull rule_name;
/// Screen name that is visible in Apphud Screens Dashboard
@property (nonatomic, readonly, copy) NSString * _Nonnull screen_name;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// These are three types of actions that are returned in <code>apphudScreenDismissAction(screenName: String, controller: UIViewController)</code> delegate method
typedef SWIFT_ENUM(NSInteger, ApphudScreenDismissAction, closed) {
  ApphudScreenDismissActionThankAndClose = 0,
  ApphudScreenDismissActionCloseOnly = 1,
  ApphudScreenDismissActionNone = 2,
};

enum ApphudSubscriptionStatus : NSInteger;

/// Custom Apphud class containing all information about customer subscription.
SWIFT_CLASS("_TtC9ApphudSDK18ApphudSubscription") SWIFT_AVAILABILITY(macos,introduced=10.14.4)
@interface ApphudSubscription : NSObject
/// Use this function to detect whether to give or not premium content to the user.
///
/// returns:
/// If value is <code>true</code> then user should have access to premium content.
- (BOOL)isActive SWIFT_WARN_UNUSED_RESULT;
/// The state of the subscription
@property (nonatomic) enum ApphudSubscriptionStatus status;
/// Product identifier of this subscription
@property (nonatomic, readonly, copy) NSString * _Nonnull productId;
/// Expiration date of subscription period. You shouldn’t use this property to detect if subscription is active because user can change system date in iOS settings. Check isActive() method instead.
@property (nonatomic, readonly, copy) NSDate * _Nonnull expiresDate;
/// Date when user has purchased the subscription.
@property (nonatomic, readonly, copy) NSDate * _Nonnull startedAt;
/// Canceled date of subscription, i.e. refund date. Nil if subscription is not refunded.
@property (nonatomic, readonly, copy) NSDate * _Nullable canceledAt;
/// Returns <code>true</code> if subscription is made in test environment, i.e. sandbox or local purchase.
@property (nonatomic, readonly) BOOL isSandbox;
/// Returns <code>true</code> if subscription was made using Local StoreKit Configuration File. Read more: https://docs.apphud.com/getting-started/sandbox#testing-purchases-using-local-storekit-configuration-file
@property (nonatomic, readonly) BOOL isLocal;
/// Means that subscription has failed billing, but Apple will try to charge the user later.
@property (nonatomic, readonly) BOOL isInRetryBilling;
/// False value means that user has canceled the subscription from App Store settings.
@property (nonatomic, readonly) BOOL isAutorenewEnabled;
/// True value means that user has already used introductory offer for this subscription (free trial, pay as you go or pay up front).
/// <em>Note:</em> If this value is false, this doesn’t mean that user is eligible for introductory offer for this subscription (for all products within the same group). Subscription should also have expired status.
/// <em>You shouldn’t use this value</em>. Use <code>checkEligibilityForIntroductoryOffer(products: callback:)</code> method instead.
@property (nonatomic, readonly) BOOL isIntroductoryActivated;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Status of the subscription. It can only be in one state at any moment.
/// Possible values:
/// <ul>
///   <li>
///     <code>trial</code>: Free trial period.
///   </li>
///   <li>
///     <code>intro</code>: One of introductory offers: “Pay as you go” or “Pay up front”.
///   </li>
///   <li>
///     <code>promo</code>: Custom promotional offer.
///   </li>
///   <li>
///     <code>regular</code>: Regular paid subscription.
///   </li>
///   <li>
///     <code>grace</code>: Custom grace period. Configurable in web.
///   </li>
///   <li>
///     <code>refunded</code>: Subscription was refunded by Apple Care. Developer should treat this subscription as never purchased.
///   </li>
///   <li>
///     <code>expired</code>: Subscription has expired because has been canceled manually by user or had unresolved billing issues.
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, ApphudSubscriptionStatus, closed) {
  ApphudSubscriptionStatusTrial = 0,
  ApphudSubscriptionStatusIntro = 1,
  ApphudSubscriptionStatusPromo = 2,
  ApphudSubscriptionStatusRegular = 3,
  ApphudSubscriptionStatusGrace = 4,
  ApphudSubscriptionStatusRefunded = 5,
  ApphudSubscriptionStatusExpired = 6,
};


/// A public protocol that provides access to Apphud’s main public methods, describing the behavior of the Rules state and custom Rules view presentation
SWIFT_PROTOCOL("_TtP9ApphudSDK16ApphudUIDelegate_")
@protocol ApphudUIDelegate
@optional
/// You can return <code>false</code> to ignore this rule. You should only do this if you want to handle your rules by yourself. Default implementation is <code>true</code>.
- (BOOL)apphudShouldPerformRuleWithRule:(ApphudRule * _Nonnull)rule SWIFT_WARN_UNUSED_RESULT;
/// You can return <code>false</code> to this delegate method if you want to delay Apphud Screen presentation.
/// Controller will be kept in memory until you present it via <code>Apphud.showPendingScreen()</code> method. If you don’t want to show screen at all, you should check <code>apphudShouldPerformRule</code> delegate method.
- (BOOL)apphudShouldShowScreenWithScreenName:(NSString * _Nonnull)screenName SWIFT_WARN_UNUSED_RESULT;
/// Return <code>UIViewController</code> instance from which you want to present given Apphud controller. If you don’t implement this method, then top visible viewcontroller from key window will be used.
/// <em>Note</em>: This delegate method is recommended for implementation when you have multiple windows in your app, because Apphud SDK may have issues while presenting screens in this case.
- (UIViewController * _Nonnull)apphudParentViewControllerWithController:(UIViewController * _Nonnull)controller SWIFT_WARN_UNUSED_RESULT;
/// Pass your own modal presentation style to Apphud Screens. This is useful since iOS 13 presents in page sheet style by default.
/// To get full screen style you should pass <code>.fullScreen</code> or <code>.overFullScreen</code>.
- (UIModalPresentationStyle)apphudScreenPresentationStyleWithController:(UIViewController * _Nonnull)controller SWIFT_WARN_UNUSED_RESULT;
/// Called when user tapped on purchase button in Apphud purchase screen.
- (void)apphudWillPurchaseWithProduct:(SKProduct * _Nonnull)product offerID:(NSString * _Nullable)offerID screenName:(NSString * _Nonnull)screenName;
/// Called when user successfully purchased product in Apphud purchase screen.
- (void)apphudDidPurchaseWithProduct:(SKProduct * _Nonnull)product offerID:(NSString * _Nullable)offerID screenName:(NSString * _Nonnull)screenName;
/// Called when purchase failed in Apphud purchase screen.
/// See error code for details. For example, <code>.paymentCancelled</code> error code is when user canceled the purchase by himself.
- (void)apphudDidFailPurchaseWithProduct:(SKProduct * _Nonnull)product offerID:(NSString * _Nullable)offerID errorCode:(enum SKErrorCode)errorCode screenName:(NSString * _Nonnull)screenName;
/// Called when screen succesfully loaded and is visible to user.
- (void)apphudScreenDidAppearWithScreenName:(NSString * _Nonnull)screenName;
/// Called when screen is about to dismiss.
- (void)apphudScreenWillDismissWithScreenName:(NSString * _Nonnull)screenName error:(NSError * _Nullable)error;
/// Notifies that Apphud Screen did dismiss
- (void)apphudDidDismissScreenWithController:(UIViewController * _Nonnull)controller;
/// (New) Overrides action after survey option is selected or feeback sent is tapped. Default is “thankAndClose”.
/// This delegate method is only called if no other screen is selected as button action in Apphud Screens editor.
/// You can return <code>noAction</code> value and use <code>navigationController</code> property of <code>controller</code> variable to push your own view controller into hierarchy.
- (enum ApphudScreenDismissAction)apphudScreenDismissActionWithScreenName:(NSString * _Nonnull)screenName controller:(UIViewController * _Nonnull)controller SWIFT_WARN_UNUSED_RESULT;
/// (New) Called after survey answer is selected.
- (void)apphudDidSelectSurveyAnswerWithQuestion:(NSString * _Nonnull)question answer:(NSString * _Nonnull)answer screenName:(NSString * _Nonnull)screenName;
@end


/// User property initializer class with reserved property names.
SWIFT_CLASS("_TtC9ApphudSDK21ApphudUserPropertyKey")
@interface ApphudUserPropertyKey : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull email;)
+ (ApphudUserPropertyKey * _Nonnull)email SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull age;)
+ (ApphudUserPropertyKey * _Nonnull)age SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull phone;)
+ (ApphudUserPropertyKey * _Nonnull)phone SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull name;)
+ (ApphudUserPropertyKey * _Nonnull)name SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull gender;)
+ (ApphudUserPropertyKey * _Nonnull)gender SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ApphudUserPropertyKey * _Nonnull cohort;)
+ (ApphudUserPropertyKey * _Nonnull)cohort SWIFT_WARN_UNUSED_RESULT;
/// Initialize with custom property key string.
/// Example:
/// \code
/// Apphud.setUserProperty(key: .init("custom_prop_1"), value: 0.5)
///
/// \endcode
- (nonnull instancetype)init:(NSString * _Nonnull)key OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// This class will contain some utils, more will be added in the future.
SWIFT_CLASS("_TtC9ApphudSDK11ApphudUtils")
@interface ApphudUtils : NSObject
/// Disables console logging.
+ (void)enableDebugLogs;
+ (void)enableAllLogs;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end






#endif
#if defined(__cplusplus)
#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
